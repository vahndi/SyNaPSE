# Atom
from atom.api import Atom, Bool, Float, Int, List, Str, Value


# Enaml
from enaml.widgets.api import CheckBox, Form, GroupBox, Label, Notebook, ObjectCombo, Page
from custom_views.fields import FloatField, IntField
from custom_views.InputsTargetsSelector import InputsTargetsSelector_View

# Models
from ._base.regression_model import ABCRegressionModel
from sklearn.linear_model import LassoLars



class LassoLars_UI(Atom):
        
    input_selector = Value(Atom)

    # alpha
    alpha = Float(1)
    alpha_min = Float(0)
    # fit_intercept
    fit_intercept = Bool(True)
    # positive
    positive = Bool(False)
    # verbose
    verbose = Bool(False)
    # normalize
    normalize = Bool(False)
    # copy_X
    copy_X = Bool(True)
    # precompute
    precompute = Str('auto')
    precompute_list = List(str, ['True', 'False', 'auto'])
    # max_iter
    max_iter = Int(500)
    max_iter_min = Int(1)
    # eps
    eps = Float(2.22044604925e-16)
    # fit_path
    fit_path = Bool(True)


class LassoLars_Model(ABCRegressionModel):

    calc_name = 'Lasso Lars'
    calc_desc = \
        'Lasso model fit with Least Angle Regression a.k.a. Lars.'
    calc_docs = ABCRegressionModel.doc_root + 'LassoLars.html'

    def setInputs(self, dataframe):
        
        self.estimator_type = LassoLars
        self.set_inputs(dataframe)
        self.uiModel = LassoLars_UI(
                            input_selector = self.input_selector.uiModel
                            )


    def getArgs(self):
        
        return {'alpha': self.uiModel.alpha,
                'fit_intercept': self.uiModel.fit_intercept,
                'positive': self.uiModel.positive,
                'verbose': self.uiModel.verbose,
                'normalize': self.uiModel.normalize,
                'copy_X': self.uiModel.copy_X,
                'precompute': (self.uiModel.precompute 
                               if self.uiModel.precompute == 'auto'
                               else bool(self.uiModel.precompute)),
                'max_iter': self.uiModel.max_iter,
                'eps': self.uiModel.eps,
                'fit_path': self.uiModel.fit_path}



enamldef LassoLars_View(GroupBox): me:

    attr model

    Notebook:

        Page:

            title = 'Inputs'
            closable = False

            InputsTargetsSelector_View:
                model := me.model.input_selector

        Page:

            title = 'Model'
            closable = False

            Form:

                Label:
                    text = 'Alpha'
                FloatField:
                    value := model.alpha
                    minimum = model.alpha_min

                Label:
                    text = 'Fit Intercept'
                CheckBox:
                    checked := model.fit_intercept

                Label:
                    text = 'Positive'
                CheckBox:
                    checked := model.positive

                Label:
                    text = 'Verbose'
                CheckBox:
                    checked := model.verbose

                Label:
                    text = 'Normalize'
                CheckBox:
                    checked := model.normalize

                Label:
                    text = 'Copy X'
                CheckBox:
                    checked := model.copy_X

                Label:
                    text = 'Precompute'
                ObjectCombo:
                    items = model.precompute_list
                    selected := model.precompute

                Label:
                    text = 'Max Iterations'
                IntField:
                    value := model.max_iter
                    minimum = model.max_iter_min

                Label:
                    text = 'eps'
                FloatField:
                    value := model.eps

                Label:
                    text = 'Fit Path'
                CheckBox:
                    checked := model.fit_path