# Atom
from atom.api import Atom, Bool, Int, List, Str, Value

# Enaml
from enaml.widgets.api import CheckBox, Form, GroupBox, Label, ObjectCombo
from custom_views.fields import FloatField, IntField
from enaml.core.api import Conditional
from custom_views.fields import Field
from custom_views.CheckBoxList import CheckBoxList_Model, CheckBoxList_View

from ._base.ABCs import ABCDataFrameToDataFrame

from pandasFunctions import getColumnNames



class SelectColumns_Model(ABCDataFrameToDataFrame):
    

    elementName = 'Select Columns'
    
    
    class ui(Atom):
        
        # method
        method = Str('string')
        method_list = List(str)
        # starts_with
        starts_with = Str()
        # ends_with
        ends_with = Str()
        # contains
        contains = Str()
        # does_not_contain
        does_not_contain = Str()
        # regular expression
        expression = Str()
        # start index
        range_start_int = Int()
        use_range_start_int = Bool()
        # end index
        range_end_int = Int()
        use_range_end_int = Bool()
        # first and last columns
        fl_columns = List(str)
        # first column name
        first_col_name = Str()
        use_first_col_name = Bool()
        # last column name
        last_col_name = Str()
        use_last_col_name = Bool() 
        # dtypes
        dtype_columns = Value(Atom)        
        # manual selection
        manual_columns = Value(Atom)        
        # order_alphabetically
        order_alphabetically = Bool(False)


    def setInputs(self, dataFrame):

        self._dataFrame = dataFrame
        # Limit selection methods based on the dtype of the columns
        if dataFrame.columns.dtype == object:
            method_list = ['string', 'regex', 'index range', 
                           'name range', 'dtypes', 'manual']
        else:
            method_list = ['index range', 'dtypes', 'manual']
            
        self.manual_columns = CheckBoxList_Model(dataFrame.columns)
        self.dtype_dict = {'float': float,
                           'int': int,
                           'number': 'number',
                           'string': object}
        self.dtype_columns = CheckBoxList_Model(sorted(self.dtype_dict.keys()))
        self.uiModel = SelectColumns_Model.ui(
                            method_list = method_list,
                            manual_columns = self.manual_columns.uiModel,
                            dtype_columns = self.dtype_columns.uiModel,
                            fl_columns = list(dataFrame.columns)
                            )

    
    def getOutputs(self):

        try:
            
            df = self._dataFrame            
            
            if self.uiModel.method == 'string':
                
                columns = getColumnNames(
                       self._dataFrame,
                       startsWith = self.uiModel.starts_with,
                       endsWith = self.uiModel.ends_with,
                       contains = self.uiModel.contains,
                       doesNotContain = self.uiModel.does_not_contain,
                       orderAlphabetically = self.uiModel.order_alphabetically)
                df = df[columns]
                
            elif self.uiModel.method == 'regex':
                
                df = df.filter(regex = self.uiModel.expression)
                if self.uiModel.order_alphabetically:
                    df = df[sorted(list(df.columns))]
                    
            elif self.uiModel.method == 'index range':
                
                rs = self.uiModel.range_start_int
                re = self.uiModel.range_end_int
                if (self.uiModel.use_range_start_int and
                    self.uiModel.use_range_end_int):
                        df = df.iloc[:, rs:re]
                elif self.uiModel.use_range_start_int:
                        df = df.iloc[:, rs:]
                elif self.uiModel.use_range_end_int:
                        df = df.iloc[:, :re]

            elif self.uiModel.method == 'name range':
                
                fc = self.uiModel.first_col_name
                lc = self.uiModel.last_col_name
                if (self.uiModel.use_first_col_name and
                    self.uiModel.use_last_col_name):
                        df = df.loc[:, fc:lc]
                elif self.uiModel.use_first_col_name:
                        df = df.loc[:, fc:]
                elif self.uiModel.use_last_col_name:
                        df = df.loc[:, :lc]
                        
            elif self.uiModel.method == 'dtypes':
                df = df.select_dtypes(
                        [self.dtype_dict[dt]
                         for dt in self.dtype_columns.getCheckedItemNames()]
                         )

            else:
                
                df = df[self.manual_columns.getCheckedItemNames()]
                # sort, if specified
                if self.uiModel.order_alphabetically:
                    df = df[sorted(list(df.columns))]

            return {'dataFrame': df}
            
        except Exception as e:
            
            return self.standard_exception(e)



enamldef SelectColumns_View(GroupBox): me:

    attr model

    Form:

        Label:
            text = 'Method'
        ObjectCombo:
            items = model.method_list
            selected := model.method


        Conditional:
            condition << (model.method == 'string' and 
                          'string' in model.method_list)
            
            Label:
                text = 'Starts With'
            Field:
                text := model.starts_with

            Label:
                text = 'Ends With'
            Field:
                text := model.ends_with

            Label:
                text = 'Contains'
            Field:
                text := model.contains

            Label:
                text = 'Does Not Contain'
            Field:
                text := model.does_not_contain
    

        Conditional:
            condition << (model.method == 'regex' and 
                          'regex' in model.method_list)

            Label:
                text = 'Expression'
            Field:
                text := model.expression


        Conditional:
            condition << model.method == 'index range'
            
            CheckBox: 
                text = 'Lower Index (inclusive)'
                checked := model.use_range_start_int
            Label:
                text = 'N/A'
                visible << not model.use_range_start_int
            IntField:
                value := model.range_start_int
                minimum = 0
                maximum = len(model.fl_columns)
                visible << model.use_range_start_int

            CheckBox:
                text = 'Upper Index (exclusive)'
                checked := model.use_range_end_int
            Label:
                text = 'N/A'
                visible << not model.use_range_end_int
            IntField:
                value := model.range_end_int
                minimum = 0
                maximum = len(model.fl_columns)
                visible << model.use_range_end_int


        Conditional:
            condition << (model.method == 'name range' and
                          'name range' in model.method_list)
            
            CheckBox: 
                text = 'First Name'
                checked := model.use_first_col_name
            Label:
                text = 'N/A'
                visible << not model.use_first_col_name
            ObjectCombo:
                items = model.fl_columns
                selected := model.first_col_name
                visible << model.use_first_col_name

            CheckBox:
                text = 'Last Name'
                checked := model.use_last_col_name
            Label:
                text = 'N/A'
                visible << not model.use_last_col_name
            ObjectCombo:
                items = model.fl_columns
                selected := model.last_col_name
                visible << model.use_last_col_name


        Conditional:
            condition << model.method == 'dtypes'
            
            Label:
                text = 'dtypes'
            CheckBoxList_View:
                model := me.model.dtype_columns


        Conditional:
            condition << model.method == 'manual'

            Label:
                text = 'Columns'
            CheckBoxList_View:
                model := me.model.manual_columns


        Label:
            text = 'Order Alphabetically'
        CheckBox:
            checked := model.order_alphabetically