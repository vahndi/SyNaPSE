# Atom
from atom.api import Atom, ContainerList, Dict, Int, Value

# Enaml
from enaml.widgets.api import (Container, DockPane, GroupBox, MPLCanvas, 
                               PushButton, RadioButton, ScrollArea)
from custom_views.RadioButtonList import RadioButtonList_View
from custom_views.CalcItem_GraphView import CalcItem_GraphView
from enaml.layout.api import hbox, vbox
from enaml.core.api import Include

# Models
from calculation import CalculationItem
from ChooseCalculation import ChooseCalculation_View

# Other
import networkx as nx
import matplotlib.pyplot as plt



class CalculationGraph_Model(object):

    
    class ui(Atom):
        
        calc_items = ContainerList(CalculationItem)
        selected_calc_item = Value(CalculationItem)
        selected_calc_item_outputs = Dict(default = {})
        graph_figure = Value()
        
    
    def __init__(self, parent, calc_dict):
        
        self._parent = parent
        self._calc_dict = calc_dict
        self.uiModel = CalculationGraph_Model.ui(selected_calc_item = None)
        self._calc_graph = nx.DiGraph()

        
    def select_calc_item(self, calc_item):
        
        self.uiModel.selected_calc_item = calc_item        
        self.uiModel.selected_calc_item_outputs = calc_item.get_outputs()


    def refresh_selected_calc_item_outputs(self):
        
        calc_item = self.uiModel.selected_calc_item
        self.uiModel.selected_calc_item = None
        self.uiModel.selected_calc_item_outputs = {}
        self.select_calc_item(calc_item)
    
    
    def item_names(self):
        
        return [node.item_name for node in self._calc_graph.nodes()]


    def draw_graph_figure(self):
        
        fig = plt.figure()
        ax = fig.add_subplot('111')
        nx.draw_graphviz(self._calc_graph, prog = 'dot', ax = ax)
        self.uiModel.graph_figure = fig
#        nx.draw_graphviz(refGraph, prog = prog, ax = axGraph, 
#                         node_size = nodeSizes, 
#                         alpha = 0.75, cmap = plt.get_cmap('brg'), 
#                         node_color = nodeColours, 
#                         width = edgeWidths, edge_cmap = plt.get_cmap('brg'), 
#                         edge_color = edgeColours)


    def relayout_nodes(self):
        
        layout = nx.graphviz_layout(self._calc_graph, prog = 'dot')
        for item, coord in layout.items():
            item.x = int(coord[0])
            item.y = int(coord[1])
        self.uiModel.calc_items = [item for item in self._calc_graph.nodes()]


    def add_calc_item(self, calc_type_name = None):

        # Get coords of selected item
        new_x = 0
        new_y = 0
        selected_item = self.uiModel.selected_calc_item
        if selected_item is not None:
            new_x = selected_item.x
            new_y = selected_item.y + 20

        # Create new item            
        constructor = self._calc_dict[calc_type_name]
        new_item = CalculationItem(model = constructor(),
                                   container = self,
                                   x = new_x, y = new_y)

        # Rename if the item name already exists
        while new_item.item_name in self.item_names():
            new_item.item_name += '_'

        # Add new node to the graph
        self._calc_graph.add_node(new_item)

        # Link outputs of selected item to new item
        if selected_item is not None: 
            try:
                # Map outputs of previous calc to inputs of this calc
                input_arg_names = new_item.model_arg_names()
                prev_outputs = selected_item.get_outputs()
                input_args_dict = {a: prev_outputs[a] 
                                   for a in input_arg_names
                                   if a in prev_outputs}
                new_item.set_inputs(input_args_dict)
                # Add an edge with the output to input mapping
                self._calc_graph.add_edge(selected_item, new_item,
                                          {a: a
                                           for a in input_arg_names
                                           if a in prev_outputs})
            except Exception as e:                
                print 'Error mapping outputs of selected calc to new calc'
                print '__class__:', str(e.__class__)
                print '__doc__:', e.__doc__
                print 'message:', e.message
                print 'args:', str(e.args)                
                return

#        self.uiModel.selected_calc_item = new_item
        self.uiModel.calc_items = [item for item in self._calc_graph.nodes()]
        self.select_calc_item(new_item)
        self.draw_graph_figure()
        self._parent.update_choosable_calc_types(calc_type_name)


def get_constraints(ui_objects, calc_items):
    
    constraints = []
    
    for ui_object, calc_item in zip(ui_objects, calc_items):
        constraints.extend([ui_object.left == calc_item.x,
                            ui_object.top == calc_item.y])

    return constraints



enamldef CalculationGraph_View(DockPane): me:


    attr model
    attr chooseCalc_Model

    
    title = 'Calculation Graph'
    dock_area = 'left'
    allowed_dock_areas = ['left', 'right'] 
    closable = False
    
    Container:
        constraints = [vbox(button_cntnr, calcs_cntnr)]
        
        Container: button_cntnr:
            constraints = [hbox(btn_add, btn_delete, btn_relayout)]
            PushButton: btn_add:
                text = 'Add Calculation'
                clicked ::
                    ChooseCalculation_View(model = me.chooseCalc_Model,
                                           calcGraphView_Model = model).show()
            PushButton: btn_delete:
                text = 'Delete Calculation'
                
            PushButton: btn_relayout:
                text = 'Re-Layout'
                clicked ::
                    model.relayout_nodes()
                    calcs_cntnr.request_relayout()

        MPLCanvas: calcs_cntnr:
            
            figure << model.uiModel.graph_figure

#        Container: calcs_cntnr:
#            ScrollArea:
#                Container:
#                    constraints << get_constraints(inc.objects, 
#                                                   model.uiModel.calc_items)
#                    Include: inc:
#                        objects << [CalcItem_GraphView(
#                                        model = calc_item,
#                                        graph_uiModel = model.uiModel
#                                        ) 
#                                    for calc_item in model.uiModel.calc_items]


