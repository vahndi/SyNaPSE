# Atom
from atom.api import Atom, ContainerList, Dict, Int, Value

# Enaml
from enaml.widgets.api import DockPane, GroupBox, PushButton
from custom_views.RadioButtonList import RadioButtonList_View

# Models
from Calculation import CalculationItem
from ChooseCalculation import ChooseCalculation_View

# Other
import networkx as nx



class CalculationGraph_Model(object):

    
    class ui(Atom):
        
        calc_items = ContainerList(CalculationItem)
        selected_calc_item = Value(CalculationItem)
        selected_calc_item_outputs = Dict(default = {})
        
    
    def __init__(self, parent, calc_dict):
        
        self._parent = parent
        self._calc_dict = calc_dict
        self.uiModel = CalculationGraph_Model.ui()
        self._calc_items = nx.DiGraph()

        
    def select_calc_item(self, calc_item):
        
        self.uiModel.selected_calc_item = calc_item        
        self.uiModel.selected_calc_item_outputs = calc_item.get_outputs()


    def refresh_selected_calc_item_outputs(self):
        
        calc_item = self.uiModel.selected_calc_item
        self.uiModel.selected_calc_item = None
        self.uiModel.selected_calc_item_outputs = {}
        self.select_calc_item(calc_item)
        

    def append_calc_item(self, calc_type_name = None):

        # Create new item            
        constructor = self._calc_dict[calc_type_name]
        new_item = CalculationItem(model = constructor(),
                                        container = self)

        # Rename if the item name already exists
        while new_item.item_name in self.get_item_names():
            new_item.item_name += '_'

        # Add new node to the graph
        self._calc_items.add_node(new_item)

        # Link outputs of selected item to new item
        selected_item = self.uiModel.selected_calc_item
        if selected_item is not None:
            try:
                # Map outputs of previous calc to inputs of this calc
                input_arg_names = new_item.model_arg_names()
                prev_outputs = selected_item.get_outputs()
                input_args_dict = {a: prev_outputs[a] 
                                   for a in input_arg_names
                                   if a in prev_outputs}
                new_item.set_inputs(input_args_dict)
                # Add an edge with the output to input mapping
                self._calc_items.add_edge(selected_item, new_item,
                                          {a: a
                                           for a in input_arg_names
                                           if a in prev_outputs})

            except Exception as e:
                
                print 'Error mapping outputs of selected calc to new calc'
                print '__class__:', str(e.__class__)
                print '__doc__:', e.__doc__
                print 'message:', e.message
                print 'args:', str(e.args)
                
                return
        
        self.uiModel.selected_calc_item = new_item
        self.uiModel.calc_items = [item for item in self._calc_items.nodes()]
        self.select_calc_item(new_item)
        self._parent.update_choosable_calc_types(calc_type_name)


def get_constraints(ui_objects, calc_items):
    
    constraints = []
    
    for ui_object, calc_item in zip(ui_objects, calc_items):
        constraints.extend([ui_object.left == calc_item.x,
                            ui_object.top == calc_item.y])

    return constraints



enamldef CalculationGraph_View(DockPane):


    attr model

    
    title = 'Calculation Graph'
    dock_area = 'left'
    allowed_dock_areas = ['left', 'right'] 
    closable = False
    
    Container: 
        constraints << get_constraints(inc.objects, model.calc_items)
        Include: inc:
            objects = [RadioButton(text = b.name) 
                       for b in model.buttons]
    
    
