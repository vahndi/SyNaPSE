# Atom
from atom.api import Atom, ContainerList, Dict, Int, Value

# Enaml
from enaml.widgets.api import (
    Container, DockPane, GroupBox, PushButton, RadioButton)
from custom_views.RadioButtonList import RadioButtonList_View
from custom_views.CalcItem_GraphView import CalcItem_GraphView
from enaml.layout.api import hbox, vbox
from enaml.core.api import Include

# Models
from calculation import CalculationItem
from ChooseCalculation import ChooseCalculation_View

# Other
import networkx as nx



class CalculationGraph_Model(object):

    
    class ui(Atom):
        
        calc_items = ContainerList(CalculationItem)
        selected_calc_item = Value(CalculationItem)
        selected_calc_item_outputs = Dict(default = {})
        
    
    def __init__(self, parent, calc_dict):
        
        self._parent = parent
        self._calc_dict = calc_dict
        self.uiModel = CalculationGraph_Model.ui(selected_calc_item = None)
        self._calc_graph = nx.DiGraph()

        
    def select_calc_item(self, calc_item):
        
        self.uiModel.selected_calc_item = calc_item        
        self.uiModel.selected_calc_item_outputs = calc_item.get_outputs()


    def refresh_selected_calc_item_outputs(self):
        
        calc_item = self.uiModel.selected_calc_item
        self.uiModel.selected_calc_item = None
        self.uiModel.selected_calc_item_outputs = {}
        self.select_calc_item(calc_item)
    
    
    def item_names(self):
        
        return [node.item_name for node in self._calc_graph.nodes()]
        

    def add_calc_item(self, calc_type_name = None):
        
        # Get coords of selected item
        new_x = 0
        new_y = 0
        selected_item = self.uiModel.selected_calc_item
        if selected_item is not None:
            new_x = selected_item.x
            new_y = selected_item.y + 20
        
        # Create new item            
        constructor = self._calc_dict[calc_type_name]
        new_item = CalculationItem(model = constructor(),
                                   container = self,
                                   x = new_x, y = new_y)

        # Rename if the item name already exists
        while new_item.item_name in self.item_names():
            new_item.item_name += '_'

        # Add new node to the graph
        self._calc_graph.add_node(new_item)
        print nx.graphviz_layout(self._calc_graph, prog = 'dot')

        # Link outputs of selected item to new item
        if selected_item is not None: #TODO: remove this condition later, once the append button's enabled property is dependent on there being an item selected
            try:
                # Map outputs of previous calc to inputs of this calc
                input_arg_names = new_item.model_arg_names()
                prev_outputs = selected_item.get_outputs()
                input_args_dict = {a: prev_outputs[a] 
                                   for a in input_arg_names
                                   if a in prev_outputs}
                new_item.set_inputs(input_args_dict)
                # Add an edge with the output to input mapping
                self._calc_graph.add_edge(selected_item, new_item,
                                          {a: a
                                           for a in input_arg_names
                                           if a in prev_outputs})

            except Exception as e:
                
                print 'Error mapping outputs of selected calc to new calc'
                print '__class__:', str(e.__class__)
                print '__doc__:', e.__doc__
                print 'message:', e.message
                print 'args:', str(e.args)
                
                return
        
        self.uiModel.selected_calc_item = new_item
        self.uiModel.calc_items = [item for item in self._calc_graph.nodes()]
        self.select_calc_item(new_item)
        self._parent.update_choosable_calc_types(calc_type_name)


def get_constraints(ui_objects, calc_items):
    
    constraints = []
    
    for ui_object, calc_item in zip(ui_objects, calc_items):
        constraints.extend([ui_object.left == calc_item.x,
                            ui_object.top == calc_item.y])

    return constraints



enamldef CalculationGraph_View(DockPane): me:


    attr model
    attr chooseCalc_Model

    
    title = 'Calculation Graph'
    dock_area = 'left'
    allowed_dock_areas = ['left', 'right'] 
    closable = False
    
    Container:
        constraints = [vbox(button_cntnr, calcs_cntnr)]
        
        Container: button_cntnr:
            constraints = [hbox(btn_add, btn_delete)]
            PushButton: btn_add:
                text = 'Add Calculation'
                clicked ::
                    ChooseCalculation_View(model = me.chooseCalc_Model,
                                           calcGraphView_Model = model).show()
            PushButton: btn_delete:
                text = 'Delete Calculation'

        Container: calcs_cntnr:
            constraints << get_constraints(inc.objects, 
                                           model.uiModel.calc_items)
            Include: inc:
                objects << [CalcItem_GraphView(model = calc_item,
                                               graph_uiModel = model.uiModel) 
                            for calc_item in model.uiModel.calc_items]
    
    
